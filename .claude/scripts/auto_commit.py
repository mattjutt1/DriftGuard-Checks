#!/usr / bin / env python3
"""
Auto - commit Script for PromptEvolver
Automatically commits changes with conventional commit messages
"""

import subprocess
from pathlib import Path


class AutoCommitter:
    def __init__(self, project_root="."):
        self.project_root = Path(project_root)
        self.repo_url = "https://github.com / mattjutt1 / prompt - wizard.git"

    def check_git_status(self):
        """Check git status and return changed files"""
        try:
            result = subprocess.run(
                ["git", "status", "--porcelain"],
                capture_output=True,
                text=True,
                cwd=self.project_root,
            )

            if result.returncode == 0:
                return result.stdout.strip().split("\n") if result.stdout.strip() else []
            return []
        except Exception as e:
            print(f"Error checking git status: {e}")
            return []

    def analyze_changes(self, status_lines):
        """Analyze git status to determine commit type and scope"""
        changes = {"added": [], "modified": [], "deleted": [], "untracked": []}

        for line in status_lines:
            if not line.strip():
                continue

            status = line[:2]
            filename = line[3:].strip()

            if status.startswith("A"):
                changes["added"].append(filename)
            elif status.startswith("M"):
                changes["modified"].append(filename)
            elif status.startswith("D"):
                changes["deleted"].append(filename)
            elif status.startswith("??"):
                changes["untracked"].append(filename)

        return changes

    def determine_commit_type(self, changes):
        """Determine conventional commit type based on changes"""
        all_files = changes["added"] + changes["modified"] + changes["deleted"] + changes["untracked"]

        # Agent - related changes
        if any(".claude / agents/" in f for f in all_files):
            return "feat", "agents"

        # Framework changes
        if "CLAUDE.md" in all_files:
            return "feat", "framework"

        # Documentation changes
        if any(f.endswith((".md", ".rst", ".txt")) for f in all_files):
            return "docs", "documentation"

        # Knowledge graph changes
        if any("knowledge_graph" in f or "embeddings" in f for f in all_files):
            return "graph", "knowledge"

        # Script changes
        if any(".claude / scripts/" in f for f in all_files):
            return "chore", "automation"

        # Source code changes
        if any(f.endswith((".py", ".js", ".ts", ".jsx", ".tsx")) for f in all_files):
            return "feat", "implementation"

        # Default
        return "chore", "misc"

    def generate_commit_message(self, commit_type, scope, changes):
        """Generate conventional commit message"""
        # Count changes
        total_changes = (
            len(changes["added"]) + len(changes["modified"]) + len(changes["deleted"]) + len(changes["untracked"])
        )

        # Create description based on type
        descriptions = {
            "feat": f"add {scope} enhancements",
            "docs": f"update {scope}",
            "chore": f"update {scope} automation",
            "graph": f"update {scope} embeddings",
            "fix": f"fix {scope} issues",
        }

        description = descriptions.get(commit_type, f"update {scope}")

        # Build commit message
        subject = f"{commit_type}({scope}): {description}"

        body = f"""
ðŸ¤– Auto - generated by Claude Code
ðŸ“Š Files changed: {total_changes}
ðŸ§  Context embeddings refreshed
âš¡ Knowledge graph updated

Changes:
"""

        if changes["added"]:
            body += f"â€¢ Added: {', '.join(changes['added'][:3])}"
            if len(changes["added"]) > 3:
                body += f" (+{len(changes['added']) - 3} more)"
            body += "\n"

        if changes["modified"]:
            body += f"â€¢ Modified: {', '.join(changes['modified'][:3])}"
            if len(changes["modified"]) > 3:
                body += f" (+{len(changes['modified']) - 3} more)"
            body += "\n"

        if changes["deleted"]:
            body += f"â€¢ Deleted: {', '.join(changes['deleted'])}\n"

        return f"{subject}\n{body.strip()}"

    def setup_git_remote(self):
        """Setup git remote if not exists"""
        try:
            # Check if remote exists
            result = subprocess.run(
                ["git", "remote", "get - url", "origin"],
                capture_output=True,
                text=True,
                cwd=self.project_root,
            )

            if result.returncode != 0:
                # Add remote
                subprocess.run(["git", "remote", "add", "origin", self.repo_url], cwd=self.project_root)
                print(f"Added remote origin: {self.repo_url}")
        except Exception as e:
            print(f"Error setting up git remote: {e}")

    def commit_changes(self):
        """Commit all changes with auto - generated message"""
        print("ðŸ”„ Committing changes to git...")

        # Check git status
        status_lines = self.check_git_status()

        if not status_lines:
            print("No changes to commit")
            return False

        # Analyze changes
        changes = self.analyze_changes(status_lines)

        # Determine commit type and scope
        commit_type, scope = self.determine_commit_type(changes)

        # Generate commit message
        commit_message = self.generate_commit_message(commit_type, scope, changes)

        try:
            # Add all changes
            subprocess.run(["git", "add", "."], cwd=self.project_root, check=True)

            # Commit with generated message
            subprocess.run(["git", "commit", "-m", commit_message], cwd=self.project_root, check=True)

            print(f"âœ… Committed changes: {commit_type}({scope})")

            # Setup remote if needed
            self.setup_git_remote()

            return True

        except subprocess.CalledProcessError as e:
            print(f"Error committing changes: {e}")
            return False

    def push_changes(self):
        """Push changes to remote repository"""
        try:
            subprocess.run(["git", "push", "origin", "main"], cwd=self.project_root, check=True)
            print("âœ… Pushed changes to remote repository")
            return True
        except subprocess.CalledProcessError as e:
            print(f"Note: Could not push to remote: {e}")
            return False


if __name__ == "__main__":
    committer = AutoCommitter()
    if committer.commit_changes():
        committer.push_changes()
